"use strict";(self.webpackChunkjotai_website=self.webpackChunkjotai_website||[]).push([[678],{2184:function(e,t,n){n.r(t),n.d(t,{Head:function(){return A},default:function(){return v}});n(5743);var a=n(702),s=n(5893);globalThis.jotaiAtomCache=globalThis.jotaiAtomCache||{cache:new Map,get:function(e,t){return this.cache.has(e)?this.cache.get(e):(this.cache.set(e,t),t)}};var o=function(){return(0,s.jsxs)("header",{children:[(0,s.jsx)(a.m,{className:"max-w-xs lg:hidden"}),(0,s.jsxs)("div",{className:"mt-8 flex items-center space-x-4 sm:space-x-8 sm:px-16 lg:mt-0 lg:px-0",children:[(0,s.jsx)("img",{src:"https://storage.googleapis.com/candycode/jotai/jotai-mascot.png",className:"w-1/3 max-w-[215px] lg:w-1/4",title:"Jotai mascot",alt:"Jotai mascot"}),(0,s.jsxs)("div",{className:"speech-bubble relative w-2/3 space-y-4 rounded-xl bg-gray-100 p-4 text-sm leading-snug text-gray-700 dark:bg-gray-900 dark:text-gray-300 sm:text-base md:text-lg lg:w-3/4 lg:p-8 lg:leading-normal",children:[(0,s.jsx)("div",{children:"没有额外的重新渲染，状态驻留在 React 中，您可以从 Suspense 和并发功能中获得全部好处。"}),(0,s.jsx)("div",{children:"它可以从简单的 React.useState 替代品扩展到具有复杂需求的大型应用程序。"})]})]})]})},r=n(5402),c=n(9759),i=n(7824),l=n(2875),h=n(7543),d=n(2005);globalThis.jotaiAtomCache=globalThis.jotaiAtomCache||{cache:new Map,get:function(e,t){return this.cache.has(e)?this.cache.get(e):(this.cache.set(e,t),t)}};var u=function(){var e=function(){var e=(0,l.KO)(h.gp),t=e[0],n=e[1];return(0,s.jsx)("input",{value:t,onChange:function(e){return n(e.target.value)},className:"w-full bg-transparent focus:!ring-transparent"})},t=function(){var e=(0,l.KO)(h.RC)[0];return(0,s.jsx)("span",{className:"flex-shrink-0 font-bold",children:e})};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("div",{className:"py-8 text-sm",children:(0,s.jsxs)("div",{className:"flex items-center rounded-lg border border-gray-300 bg-white px-4 py-2 text-lg focus-within:ring focus-within:ring-blue-400 dark:border-gray-800 dark:bg-gray-950 dark:focus-within:ring-teal-700",children:[(0,s.jsx)(e,{}),(0,s.jsx)(t,{})]})}),(0,s.jsx)(d.E,{children:"import { atom, useAtom } from 'jotai'\n\n// 创建你的原子和衍生物\nconst textAtom = atom('hello')\nconst uppercaseAtom = atom(\n  (get) => get(textAtom).toUpperCase()\n)\n\n// 在您的应用程序中的任何位置使用它们\nconst Input = () => {\n  const [text, setText] = useAtom(textAtom)\n  const handleChange = (e) => setText(e.target.value)\n  return (\n    <input value={text} onChange={handleChange} />\n  )\n}\n\nconst Uppercase = () => {\n  const [uppercase] = useAtom(uppercaseAtom)\n  return (\n    <div>Uppercase: {uppercase}</div>\n  )\n}\n\n// 现在你有了组件\nconst App = () => {\n  return (\n    <>\n      <Input />\n      <Uppercase />\n    </>\n  )\n}"})]})},m=n(5900),g=n.n(m),x=n(7294);globalThis.jotaiAtomCache=globalThis.jotaiAtomCache||{cache:new Map,get:function(e,t){return this.cache.has(e)?this.cache.get(e):(this.cache.set(e,t),t)}};var p=function(e){var t=e.children,n=(0,x.useState)(!1),a=n[0],s=n[1];return(0,x.useEffect)((function(){s(!0)}),[]),a?t:null};globalThis.jotaiAtomCache=globalThis.jotaiAtomCache||{cache:new Map,get:function(e,t){return this.cache.has(e)?this.cache.get(e):(this.cache.set(e,t),t)}};var j=function(){var e=(0,l.KO)(h.H_),t=e[0],n=e[1];return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("div",{className:"py-8",children:(0,s.jsx)(p,{children:(0,s.jsxs)("div",{className:g()(t?"bg-gray-900 text-gray-100":"bg-gray-100 text-gray-900","flex items-center space-x-4 rounded-xl p-4 transition duration-300 ease-in-out lg:space-x-8 lg:p-8"),children:[(0,s.jsx)("div",{children:(0,s.jsx)("button",{onClick:function(){return n(!t)},className:g()(t?"bg-gray-700":"bg-gray-300","dark:focus-teal-700 relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-opacity duration-200 ease-in-out focus:outline-none focus:ring focus:ring-blue-400"),children:(0,s.jsx)("span",{className:g()(t?"translate-x-5":"translate-x-0","pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out"),"aria-hidden":"true"})})}),(0,s.jsx)("div",{className:"text-sm leading-relaxed lg:text-lg",children:"此切换将通过 localStorage 在用户会话之间保留。"})]})})}),(0,s.jsx)(d.E,{children:"import { useAtom } from 'jotai'\nimport { atomWithStorage } from 'jotai/utils'\n\n// 设置字符串键和初始值\nconst darkModeAtom = atomWithStorage('darkMode', false)\n\nconst Page = () => {\n  // 像任何其他原子一样使用持久化状态\n  const [darkMode, setDarkMode] = useAtom(darkModeAtom)\n  const toggleDarkMode = () => setDarkMode(!darkMode)\n  return (\n    <>\n      <h1>Welcome to {darkMode ? 'dark' : 'light'} mode!</h1>\n      <button onClick={toggleDarkMode}>toggle theme</button>\n    </>\n  )\n}"})]})},f=n(4752);globalThis.jotaiAtomCache=globalThis.jotaiAtomCache||{cache:new Map,get:function(e,t){return this.cache.has(e)?this.cache.get(e):(this.cache.set(e,t),t)}};var b=function(){var e=(0,l.KO)(h.o_),t=e[0],n=e[1];return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)("div",{className:"flex items-center space-x-8 pt-4 lg:pt-8 lg:pb-4",children:[(0,s.jsx)(f.z,{onClick:function(){return n((function(e){return e+1}))},icon:"plus",className:"focus:ring",children:"Increment"}),(0,s.jsx)("span",{className:"text-3xl font-bold ordinal slashed-zero tabular-nums",children:t})]}),(0,s.jsx)(d.E,{children:"import { useAtom } from 'jotai'\nimport { atomWithImmer } from 'jotai/immer'\n\n// 使用基于 immer 的写入函数创建一个新原子\nconst countAtom = atomWithImmer(0)\n\nconst Counter = () => {\n  const [count] = useAtom(countAtom)\n  return (\n    <div>count: {count}</div>\n  )\n}\n\nconst Controls = () => {\n  // setCount === update: (draft: Draft<Value>) => void\n  const [, setCount] = useAtom(countAtom)\n  const increment = () => setCount((c) => (c = c + 1))\n  return (\n    <button onClick={increment}>+1</button>\n  )\n}"})]})};function v(){return(0,s.jsxs)(r.A,{children:[(0,s.jsx)(o,{}),(0,s.jsxs)("div",{className:"mt-8 space-y-8 lg:mt-16 lg:space-y-16",children:[(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{children:"介绍"}),(0,s.jsx)("p",{children:"Jotai 受 Recoil 启发的原子模型采用自下而上的方法来进行 React 状态管理。 可以通过组合原子来构建状态，并且渲染基于原子依赖性进行优化。 这解决了 React 上下文的额外重新渲染问题，并消除了对 memoization 技术的需要。"})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{children:"核心 API"}),(0,s.jsxs)("p",{children:["Jotai 有一个非常小的 API，并且是面向 TypeScript 的。 它与 React 的集成 ",(0,s.jsx)(c.Z,{children:"useState"})," hook 一样简单易用，但所有状态都是全局可访问的，派生状态易于实现，并且自动消除了额外的重新渲染。"]}),(0,s.jsx)(u,{})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{children:"额外的 utilities"}),(0,s.jsxs)("p",{children:["Jotai 包还包括一个 ",(0,s.jsx)(c.Z,{children:"jotai/utils"})," 包。 这些函数增加了对在 localStorage（或 URL 哈希）中保留原子状态、在服务器端渲染期间混合原子状态、创建具有 set 函数（包括类似 Redux 的 reducers 和 action 类型）的原子等等的支持！"]}),(0,s.jsx)(j,{})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{children:"第三方集成"}),(0,s.jsx)("p",{children:"每个官方第三方集成还有额外的捆绑包。 Immer、Optics、Query、XState、Valtio、Zustand、Redux 和 URQL。"}),(0,s.jsxs)("p",{children:["一些集成提供了具有备用集合函数的新原子类型，例如  ",(0,s.jsx)(c.Z,{children:"atomWithImmer"}),"，而其他集成则提供了具有与其他状态管理库的双向数据绑定的新原子类型，例如与 Redux 存储绑定的 ",(0,s.jsx)(c.Z,{children:"atomWithStore"}),"。"]}),(0,s.jsx)(b,{})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("h2",{children:"学习更多"}),(0,s.jsx)("p",{children:"查看 Jotai 的创建者 Daishi 的免费 Egghead 课程。"}),(0,s.jsx)("a",{href:"https://egghead.io/courses/manage-application-state-with-jotai-atoms-2c3a29f0",target:"_blank",rel:"noreferrer",className:"mt-4 block",children:(0,s.jsx)("img",{src:"https://storage.googleapis.com/candycode/jotai/jotai-course-banner.jpg",className:"block rounded-md shadow-lg dark:!shadow-none sm:rounded-lg",alt:"Jotai course",title:"Jotai course"})})]})]})]})}globalThis.jotaiAtomCache=globalThis.jotaiAtomCache||{cache:new Map,get:function(e,t){return this.cache.has(e)?this.cache.get(e):(this.cache.set(e,t),t)}};var A=function(){return(0,s.jsx)(i.h,{})}}}]);
//# sourceMappingURL=component---src-pages-index-js-b58f5de505c0e1bbe0fd.js.map